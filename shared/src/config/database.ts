import { Pool, PoolConfig } from 'pg';\nimport { createClient } from 'redis';\nimport type { RedisClientType } from 'redis';\n\n// PostgreSQL connection\nexport const createDatabasePool = (config?: Partial<PoolConfig>): Pool => {\n  const defaultConfig: PoolConfig = {\n    host: process.env.DB_HOST || 'localhost',\n    port: parseInt(process.env.DB_PORT || '5432'),\n    database: process.env.DB_NAME || 'jewelry_shop_db',\n    user: process.env.DB_USER || 'jeweler',\n    password: process.env.DB_PASSWORD || 'jeweler123',\n    max: parseInt(process.env.DB_POOL_SIZE || '20'),\n    idleTimeoutMillis: parseInt(process.env.DB_IDLE_TIMEOUT || '30000'),\n    connectionTimeoutMillis: parseInt(process.env.DB_CONNECTION_TIMEOUT || '2000'),\n    ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false\n  };\n\n  return new Pool({ ...defaultConfig, ...config });\n};\n\n// Redis connection\nexport const createRedisClient = (): RedisClientType => {\n  const redisUrl = process.env.REDIS_URL || 'redis://localhost:6379';\n  \n  const client = createClient({\n    url: redisUrl,\n    socket: {\n      reconnectStrategy: (retries) => Math.min(retries * 50, 1000)\n    }\n  });\n\n  client.on('error', (err) => {\n    console.error('Redis Client Error:', err);\n  });\n\n  client.on('connect', () => {\n    console.log('Redis Client Connected');\n  });\n\n  return client;\n};\n\n// Database health check\nexport const checkDatabaseHealth = async (pool: Pool): Promise<boolean> => {\n  try {\n    const client = await pool.connect();\n    await client.query('SELECT 1');\n    client.release();\n    return true;\n  } catch (error) {\n    console.error('Database health check failed:', error);\n    return false;\n  }\n};\n\n// Redis health check\nexport const checkRedisHealth = async (client: RedisClientType): Promise<boolean> => {\n  try {\n    await client.ping();\n    return true;\n  } catch (error) {\n    console.error('Redis health check failed:', error);\n    return false;\n  }\n};\n\n// Database migration utilities\nexport const runMigration = async (pool: Pool, sql: string): Promise<void> => {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n    await client.query(sql);\n    await client.query('COMMIT');\n  } catch (error) {\n    await client.query('ROLLBACK');\n    throw error;\n  } finally {\n    client.release();\n  }\n};\n\n// Common queries\nexport const queries = {\n  // User queries\n  findUserByEmail: 'SELECT * FROM users WHERE email = $1 AND is_active = true',\n  findUserById: 'SELECT * FROM users WHERE id = $1 AND is_active = true',\n  createUser: `\n    INSERT INTO users (email, password_hash, first_name, last_name, role, preferred_language, phone)\n    VALUES ($1, $2, $3, $4, $5, $6, $7)\n    RETURNING *\n  `,\n  updateUserLastLogin: 'UPDATE users SET last_login_at = CURRENT_TIMESTAMP WHERE id = $1',\n\n  // Gold rates queries\n  getCurrentGoldRates: 'SELECT * FROM metal_types WHERE is_active = true ORDER BY name',\n  updateGoldRate: 'UPDATE metal_types SET current_rate = $1, last_updated = CURRENT_TIMESTAMP WHERE id = $2',\n  insertGoldRateHistory: `\n    INSERT INTO gold_rates_history (metal_type_id, rate_per_gram, rate_per_tola, rate_source)\n    VALUES ($1, $2, $3, $4)\n  `,\n\n  // Inventory queries\n  findJewelryItems: `\n    SELECT ji.*, c.name as category_name, mt.name as metal_name, p.purity_name\n    FROM jewelry_items ji\n    LEFT JOIN categories c ON ji.category_id = c.id\n    LEFT JOIN metal_types mt ON ji.metal_type_id = mt.id\n    LEFT JOIN purities p ON ji.purity_id = p.id\n    WHERE ji.is_available = true\n    ORDER BY ji.created_at DESC\n    LIMIT $1 OFFSET $2\n  `,\n  findItemBySKU: 'SELECT * FROM jewelry_items WHERE sku = $1 AND is_available = true',\n  updateItemStock: 'UPDATE jewelry_items SET stock_quantity = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2',\n\n  // Order queries\n  createOrder: `\n    INSERT INTO orders (order_number, customer_id, staff_id, order_type, subtotal, total_amount)\n    VALUES ($1, $2, $3, $4, $5, $6)\n    RETURNING *\n  `,\n  updateOrderStatus: 'UPDATE orders SET status = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2',\n  findOrdersByCustomer: 'SELECT * FROM orders WHERE customer_id = $1 ORDER BY created_at DESC',\n\n  // Making charges queries\n  getMakingCharges: `\n    SELECT * FROM making_charges_config \n    WHERE is_active = true \n    AND (category_id = $1 OR category_id IS NULL)\n    AND (purity_id = $2 OR purity_id IS NULL)\n    ORDER BY category_id NULLS LAST, purity_id NULLS LAST\n    LIMIT 1\n  `\n};